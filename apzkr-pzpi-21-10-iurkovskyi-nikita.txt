Міністерство освіти і науки України
Харківський національний університет радіоелектроніки


Факультет комп’ютерних наук


Кафедра програмної інженерії


КУРСОВА РОБОТА
ПОЯСНЮВАЛЬНА ЗАПИСКА
з навчальної дисципліни «Архітектура програмного забезпечення»
Тема роботи: Програмна система для автоматизації кулінарії на харчових підприємствах


		Студент гр. ПЗПІ-21-10	_________________   Юрковський Н.Ю.
							(підпис)
		Керівник роботи		_________________ доц. Лещинська І.О.
							(підпис)
						Роботу захищено «__» ______ 2024.р
					          з оцінкою _______________________
		Комісія:		          _______________ доц. Лещинський В.О.
								(підпис)
					          _______________ доц. Лещинська І.О.
								(підпис)
						_______________ ст. викл. Сокорчук І.П.
								(підпис)
Харків
2024 р.
Харківський національний університет радіоелектроніки 
Факультет комп’ютерних наук                    Кафедра програмної інженерії 
Спеціальність 121 – Інженерія програмного забезпечення
Курс          3              Семестр                                      6
Навчальна дисципліна Архітектура програмного забезпечення 

ЗАВДАННЯ 
НА КУРСОВУ РОБОТУ СТУДЕНТОВІ

Юрковському Нікіті Юрйовичу
1. Тема проєкту: «Програмна система для автоматизації кулінарії на харчових підприємствах».
2. Термін узгодження завдання з лабораторних робіт: «23» березня 2024 р. 
3. Термін здачі завдання з лабораторних робіт: «15» червня 2024 р.
4. Вихідні дані до проєкту: У програмній системі передбачити: можливість вибору певної страви чи напою в залежності від її виду; визначення вмісту інгредієнтів у страві/напої; можливість замовлення страв, вказавши вміст; реалізацію кошика; підбір страв, що мають у складі інгредієнти, які обрав користувач; пошук закладів, де можна отримати замовлені страви; відображення рекомендацій стосовно страв, що можуть сподобатися користувачеві, здійснення адміністрування програмної системи. 
Використовувати Windows 10, PostgreSQL 13.3, PyCharm 2021.1.1. 
5. Зміст звітів з лабораторних робіт (перелік питань, що належить розробити): На лабораторній роботі №1 потрібно розробити аркуш завдання та описати проєкт у форматі Vision & Scope. На лабораторній роботі №2 потрібно розробити серверну / back-end частину систему на мові програмування Python та фреймворку Django. На лабораторній роботі №3 потрібно розробити програмне забезпечення для IoT пристрою. На лабораторній роботі №4 пристрою потрібно розробити клієнтську / front-end частину систему на HTML, CSS, JavaScript та використовуючи React.js.  На лабораторній роботі №5 потрібно розробити мобільний програмний застосунок для мобільної платформи Android на мові програмування Kotlin. Перелік графічного матеріалу (діаграми, рисунки, інтерфейси): UML діаграма розгортання, UML діаграма прецедентів, ER-модель даних, UML діаграма компонент веб-застосунку та мобільного застосунку, UML діаграма пакетів веб-застосунку та мобільного застосунку. 






















КАЛЕНДАРНИЙ ПЛАН

№
Основні етапи виконання проєкту 
в рамках лабораторних робіт
Термін виконання етапів
Примітка
1
Написання Vision and Scope документу
09.04.2024
Виконано
2
Написання серверної / back-end частини
17.04.2024
Виконано
3
Розробка програмного забезпечення для IoT або
SmartDevice пристрою
16.05.2024
Виконано
4
Написання клієнтської / front-end частини
24.05.2024
Виконано
5
Розробка мобільного застосунку
10.06.2024

     Дата видачі теми проєкту «	25    » 		березня	 2024 р. 

          Керівник 					          	          доц. Лещинська І.О.
						       (підпис)

      Завдання прийняв до виконання 
      ст.гр. ПЗПІ-21-10                               ____________       Юрковський Н.Ю.
                                                                             (підпис)










РЕФЕРАТ


     Пояснювальна записка до курсової роботи: 36 сторінок, 12 рисунків, 5 джерел.
     ГАСТРОНОМІЯ, КУЛІНАРІЯ, ХАРЧОВА ПРОМИСЛОВІСТЬ, ХАРЧОВИЙ СЕРВІС, DJANGO, МОБІЛЬНИЙ ЗАСТОСУНОК, ПРОГРАМНИЙ ПРОДУКТ, ІНФОРМАЦІЙНА СИСТЕМА.
     
     Об'єктом досліджень є галузь харчової промисловості, зокрема ресторанний бізнес та гастрономічні заклади, з метою створення програмної системи, що сприятиме автоматизації кулінарного процесу та оптимізації роботи на харчових підприємствах.
     Програмна система для автоматизації кулінарії на харчових підприємствах створена з метою полегшення кулінарного процесу та оптимізації витрат на додаткове обладнання. Ця система спрямована на покращення якості готових страв шляхом використання інтегрованих технологічних рішень та автоматизації ключових процесів приготування. 
     Розробка програмного продукту базувалася на використанні різних інструментів та технологій. Для серверної частини використовувалися середовища розробки Visual Studio Code та android studio, а також фреймворки Django та Node.js з Express. Клієнтська частина веб-додатку була реалізована за допомогою бібліотеки React.js. Для створення мобільного додатку використовувалася мова розробки kotlin і платформа кодування android studio. 
     Під час розробки створено програмну систему, що дозволяє оглядати асортимент страв, дає можливість придбати їх за допомогою як веб-додатку так і за допомогою мобільного застосунку, а розумні пристрої допомагають у приготуванні цих страв.
ЗМІСТ

ВСТУП	7
1 СПЕЦИФІКАЦІЯ ПРОГРАМИ	8
1.1	Основний функціонал системи	8
1.1.1	Обов’язки адміністратора	9
1.1.2 Функції користувача зі звичайним акаунтом	9
1.1.3 Функції користувача з платною підпискою	10
1.2	Огляд функцій розумного пристрою	10
1.3	Огляд функцій веб-клієнта	12
1.3.1	Авторизація і регістрація	12
1.3.2	Меню пошуку харчів	13
1.3.3	Меню фільтрації товару	14
1.3.4	Детальна інформація про харчі	15
1.3.5	Відгуки на харчі	15
1.3.7	Зміна мови інтерфейсу	16
1.3.8	Установи гастрономії	17
2	ПРОЕКТУВАННЯ ПРОГРАМИ	18
2.3	Архітектура серверної частини	18
2.4	Архітектура IOT смарт-девайсу	25
ВИСНОВКИ	27
ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАННЯ	28
ДОДАТОК А	29
ДОДАТОК Б	32
ДОДАТОК В	34
ДОДАТОК Ж	38





ВСТУП


     Сутність проекту зосереджено на розробці додатку, який допоможе обробляти інтернет-замовлення. Це дозволяє клієнтам вибирати зміст індивідуальних складових і те, що він хоче, якщо мінливість зазначена у посібнику для приготування страв.  
     Цей продукт створюється для введення у громадські гастрономії з метою охопити перспективну аудиторію у великому обсязі. Для кого саме розроблюється утиліта? Для простих робітників, для торопливих школярів та інших, у яких завжди не вистачає часу на сніданок. Заодно, можна охопити велику кількість кафе і ресторацій, в яких є окреме меню, яке може привернути інтерес майбутніх клієнтів.
     Однією з можливостей, буде оглянути список страв, які надає кожне місце харчування. Це також дозволяє відвідувачу вибрати блюдо з індивідуальними складовими.
     Додаток має можливість розвиватися, бо складність забезпечення людського роду їжею буде актуальною завжди, а роботизація цієї роботи дасть змогу найефективніше вирішити це.
     Щодо поширення системи, то у цього додатку є велике майбутнє. По-перше, це принесе щось новеньке на ринок кафе і ресторанів, по-друге – цим додатком ми закриємо питання великих черг і зможемо це зробити як продуктивно так і делікатно.
     
     
     



1 СПЕЦИФІКАЦІЯ ПРОГРАМИ
     1.1 Основний функціонал системи

     Для початку, нам треба зрозуміти як поводить себе клієнт під час роботи з додатком. Для цього була розроблена діаграма UseCase (див. рис. 1.1). Такий підхід дозволяє зрозуміти, як користувач взаємодіє з програмою та які операції він виконує.
      
Рисунок 1.1 - Діаграма прецедентів майбутнього додатку
     Ми можемо бачити, що додатком користуються не тільки клієнти, але й адміністратори і люди, які мають як преміум доступ так і звичайний акаунт, які замовляють та отримують харчування через систему, та персонал харчувальних закладів.
1.1.1 Обов’язки адміністратора 

     Перейдемо до функцій адміністратора. По-перше, він має повний доступ до функцій системного адміністрування, це означає, що адміни можуть здійснювати різноманітні завдання. Сюди входять – створення резервного збереження бази даних, реконструкція їх у разі успішної роботи програмного додатку, також сюди можна віднести управління сертифікатом і відстеження дійсності SSL-сертифіката. За великої потреби, можна буде їх оновити. Ще, адміністратори, будуть слідкувати за даними, записами програмного забезпечення. Це означає, що вони повинні слідкувати за таблицями та перевіряти наявну в них інформацію і в разі потреби редагувати їх.
     
      1.1.2 Функції користувача зі звичайним акаунтом

     Так як у цього виду клієнта лише безкоштовний тариф, то він має можливість керувати головними функціями і робити замовлення страв. Щоб зробити замовлення, для цього в нього буде меню блюд, що зможе приготувати певне харчове підприємство. Ще, клієнти зможуть вивчити наявні страви, відсортувати їх і мати змогу знайти потрібну страву через пошукову систему. Клієнт зможе шукати кулінарні ідеї, що складаються з обраних ним інгредієнтів і знаходити заклади громадського харчування у своєму регіоні, які готують страви за їхнім списком індивідуальних складових.  Також, користувач може вказати, які складові можуть бути пропущені у кулінарному рецепту.



     1.1.3 Функції користувача з платною підпискою
     
     Клієнти з платним тарифом мають змогу замовляти їжу в Інтернеті в будь-який час на свій вибір, а також мають привілеї при розрахунку черг. Він може швидко переміститися в центр черги, яка складається лише з клієнтів з безкоштовним акаунтом.
      
     Взаємодія з додатком відбувається у співробітників підприємств їдальні. Коли в машині для приготування лотків недостатньо визначених компонентів, він оголошує це і цей співробітник зобов’язаний повторно заповнити компоненти системи, щоб підтримувати обслуговування користувачів.
     
     1.2 Огляд функцій розумного пристрою

     Діаграма стану була розроблена для характеризації манери дій системного об'єкта, зокрема реактивного об'єкта (поведінка, що характеризується реакцією на зовнішні події) (див. рис. 1.2). У ньому докладно описується стан користувача, включаючи процес несанкціонованого та активного переходу з одного стану в інший. Ситуація, коли об'єкт знаходиться в рамках функціонування системи, зрозуміла, які кроки необхідно зробити, щоб перейти з одного стану в інший.

Рисунок 1.2 – Діаграма станів програмної системи

     Інфраструктура back-end частини додатку приймає інформацію з comunication-роз’єму, проаналізувавши потік надісланих ним байтів і інтерпретувавши у текст. Звернувши увагу, що чіп ардуіно використовує міні-usb для підключення до хоста.
     
     Оскільки архітектура програмного додатку знаходиться всередині одного апарату, існує два рівні (рівень бізнес-логіки, на якому виконується управління чергою, і рівень процесу приготування страв)
     
     
     
     1.3 Огляд функцій веб-клієнта
     1.3.1 Авторизація і регістрація

     Коли клієнт запускає додаток то бачить спочатку вікно авторизації (див. рис. 1.3). Потім, коли клієнт авторизується одразу відкривається вікно головної сторінки (див. рис. 1.4). Якщо клієнт не зареєстрований, то з лівого боку є кнопка реєстрації. Коли клієнт її натисне, відкриється меню регістрації (див. рис. 1.5).
     

Рисунок 1.3 – Вікно авторизації на сайті


Рисунок 1.4 – Головне меню на сайті

Рисунок 1.5 – Меню регістрації на сайті

     1.3.2 Меню пошуку харчів

     На головній сторінці одразу клієнт може шукати певне блюдо, яке йому потрібно. Для цього вгорі є поле для вводу (див. рис. 1.6). Коли клієнт вводить блюдо, йому одразу показується потрібні харчі (див. рис. 1.7). 
     

Рисунок 1.6 – Поле для пошуку на сайті

Рисунок 1.7 – Результат роботи пошуку

     1.3.3 Меню фільтрації товару

     Безпосередньо, харчі можна сортувати. Тут є декілька параметрів, за якими можна знаходити потрібне. Перше, це тип блюда, друге – популярність і третє – рейтинг харчів (див. рис. 1.8). 
     

Рисунок 1.8 – Зона фільтрації блюд 
     1.3.4 Детальна інформація про харчі
     
     Тепер детальніше про харчі. Якщо клієнт захоче дізнатися детальніше про певне блюдо, то він зможе натиснути на нього і в клієнта відкриється детальний опис про певне блюдо. Тут також можна дізнатися з чого воно складається і такі дані як масу та об’єм (див. рис. 1.9).
     

Рисунок 1.9 – Детальний опис харчів 

     1.3.5 Відгуки на харчі

     Знизу під описом блюда є відгуки про «товар» (див. рис. 1.10). Клієнти можуть додавати свої відгуки про певні харчі і читати відгуки інших. І, звичайно, тут є дата коли коментар був створений.

Рисунок 1.10 – Меню відгуків на сайті 

     1.3.7 Зміна мови інтерфейсу

     Невелика функція, але дуже гарно доповнює додаток. В правому верхньому куті є глобус при натисканні на який випадає меню зі зміною мови. На вибір є дві мови – англійська та українська. При натисканні змінюється весь зовнішній вигляд утиліти (див. рис. 1.11).


Рисунок 1.11 – Меню відгуків на сайті 




     1.3.8 Установи гастрономії

     В цьому розділі є окремі функції. При виборі блюда, відкривається лист з установами, які зможуть готувати це. При виборі декількох страв буду видаватися лише ті організації, які можуть створити обидва блюда, а не лише одне з вибраних. Так, наприклад, олів’є готує ресторан Hola (див. рис. 1.12). 
     

Рисунок 1.12 – Розділ пошуку установи 









2 ПРОЕКТУВАННЯ ПРОГРАМИ
     2.3 Архітектура серверної частини

     Серверна частина була спроектована за допомогою фреймворку Django та використанням веб-фреймворку Django з використанням протоколу TCP/IP.
     За основу для зберігання даних була взята СУБД PostgreSQL (див. рис. 2.1, 2.2), яка пов’язана із backend-сервером, що містить основну бізнес-логіки системи.  

Рисунок 2.1 – Структура бази даних

Рисунок 2.2 – Структура бази даних

     Спроектована база даних дає можливість записувати все, що потрібно, щоб переконатися, що всі зазначені операції були виконані в попередньому розділі. Модель даних була спроектована за допомогою інструмента Django orm. Платформа Django робить можливим визначення моделі даних, створюючи класи, перераховуючи поля, зо розташовані у певних таблицях та вказуючи тип даних, що представляє вміст полів.
     Розглянемо як працює архітектура програмного додатку. У даній системі я використав модель MVC (див. рис. 2.3). Інформація подана у формі об’єктів, що означає, що проектуються класи, а його поля виконують роль строк таблиць у базі даних. Можливості ORM дали змогу перетворювати класи у таблиці, а поля відповідних класів у взаємозв’язки даних. 
     
     Рисунок 2.3 – Архітектура побудована за допомогою Model-View-Controller (MVC)
     Щоб відбувся зв’язок між логікою інфраструктури та окремих частин додатку, ми застосовуємо фреймворк Django Rest. Образи встановлюють список можливостей, що представлені у користувальницькому інтерфейсі. Серіалізатор може використовуватись образом для представлення наборуданих у зручному форматі. Завдяки JSON-формату, інформація моделей зможе перетворитися і тим самим зручно передатися замовнику. Використання JSON у клієнтських утилітах полегшується завдяки його поширеності та широкому охваті підтримки. Система маршрутизації API визначає URL-адреси, які використовуються для доступу до різних компонентів API.

     Для входу в утиліту клієнти вводять свої дані. Якщо дані вірні, система генерує два JWT-токени: access-токен та refresh-токен. Ці дані зберігаються і на на клієнтському пристрої він надсилається разом із кожним записом у заголовку для створення нового маркера доступу після закінчення терміну дії старого маркера доступу. До плюсів цього методу можемо віднести можливість . Також можна віддати перевагу різним методам шифрування для того, щоб згенерувати токени та їх час очікування. У цьому проекті ми вибрали такий метод як  HMAC і час очікування приблизно 1 година.

     З метою збереження цілісності інформації та можливого поновлення механізму у разі аварії впроваджено функціонал резервного копіювання та реконструкції сховища даних. Щоб реалізувати цей функціонал використаємо бібліотеки Django-dbbackup. Після отримання запиту POST було зроблено API, який викликає певний функціонал для генерування резервної копії або відтворення. Ці функції здійснюються на рівні системного програмного забезпечення, отримує відповідь з успішним виконанням (див. рис. 2.4).
Рисунок 2.4 – Метод відновлення бази даних та створення копії

     Для захисту ваших даних запроваджується сертифікат, який забезпечує тільки захищений зв’язок з клієнтською частиною. API для управління сертифікатами був сформований і дозволяє їх оновлювати за запитом. Попередження програмної утиліти також застосовуються, коли термін дії сертифікатів закінчується, щоб адміністратори мали змогу знати, коли їх слід замінити (див. рис. 2.5).

Рисунок 2.5 – Метод відновлення бази даних та створення копії

     За бізнес логіку нашої back-end частини відповідає смарт-девайс. Він вибирає із певного списку їжу, яку буде готувати з певних складових (див. додаток А). Також девайс має можливість знайти певний ресторан, який зготує конкретне блюдо (див. додаток Б).
 
     У якості вибору їжі, клієнтом у вигляді запитів посилаються складові, які повинні бути частиною блюд, і кількість цих складових, яких не повинно бути у блюді. Далі приходить перечень усіх блюд і вже наступний крок, це підбір для кожної страви певної кількості складових. Потім відбувається математична операція з між складовими, що передав клієнт і інгредієнтів, які не повинні входити до блюда. Тим самим ми перевіряємо, чи підходить нам ця страва. Як слідство, ми отримуємо дані про блюда, які мають наші складові і які не мають декількох складових, але за умови яку ввів наш клієнт.
 
     Щоб знайти потрібну нам установу з приготування їжі, клієнт вибирає певні блюда і місцерозташування, яке він забажає. (див. рис. 2.6). Сюди входять такі дані як провулок, держава та населений пункт (див. рис. 2.7). Програма оброблює дані і знаходить потрібні нам пристрої, що зможуть виконати наше замовлення. Якщо блюда, які може приготувати ця установа співпадає з блюдами, які замовив клієнт, то ця установа задовольняє нашим критерія (див. рис. 2.8).


Рисунок 2.6 – Страва, з певними даними


Рисунок 2.7 – Сутність закладу громадського харчування


Рисунок 2.8 – Тип автомата, зв’язок між автоматом та закладом та зі стравою


     2.4 Архітектура IOT смарт-девайсу 

     SmartDevice було створено на базі популярної платформи для розробки вбудованих систем Arduino Nano. 
     Якщо нових даних не надійшло, здійснюється перевірка, чи наявні у черзі замовлення, що мають бути приготовані. У противному разі отримані дані розглядаються як такі, що знаходяться у форматі JSON, доступ до окремих елементів даних відбувається аналогічним чином, як і виконується звернення до об’єктів та масивів JavaScript. Отримуються усі нові замовлення, інформація про склад кожної страви замовлень (див. додаток ), після чого визначається, яке місце у черзі отримає поточне замовлення. 
     Існує наступне правило: замовлення користувача, що має платну підписку, може потрапити у позицію, що знаходиться до середини черги, при цьому не можна випереджати інших користувачів із платною підпискою, а користувачів, що користуються системою безкоштовно, можна випереджати максимум 3 рази. Після цього перевіряється, яка страва має готуватися наступною, і якщо у черзі наявні замовлення, то перше із них вилучається із черги та готується (див. рис. 2.9). 
     Після приготування автомат очікує 5 секунд та знову перевіряє наявність нових замовлень. 

     Рисунок 2.9 – Реалізація управління замовленнями 


ВИСНОВКИ
     
     
     У ході розробки програмної системи на тему: «Програмна система для автоматизації кулінарії на харчових підприємствах» був створений продукт, за допомогою якого користувач може робити онлайн замовлення як через веб-додаток так і за допомогою мобільного застосунку. Розумні пристрої можуть створювати різні блюда і ідентифікувати про це кухарів. Також є можливість переглянути асортимент який є у кожному закладі. 
     Як результат, була створена велика автоматична система. В ході роботи були засвоєні навички роботи з різними технологіями, такими як: ReactJS, Python, Django та інші. Навчився створювати свої розумні пристрої за допомогою IOT девайсів. Підтягнув навички роботи з Visual Studio Code.
     Додаток, який зможе розв’язати сучасні проблеми з їжею, а автоматизований процес зможе це зробити результативно. Це все, має великі перспективи у майбутньому і досить скоро розгорнеться у всіх куточках країни. 
     
     
     
     
     
     
     
     
     



ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАННЯ


     1. Олександр Макаров. "Django. Розробка веб-додатків на Python". — Київ: Видавничий дім "Будівельник", 2019. – 260 с.
     2. Kathy Sierra, Bert Bates. "Head First Java". 2nd ed. — O'Reilly Media, 2005.
     3. Архітектура програмного забезпечення. Здобутки чистої архітектури". — Київ: Техніка, 2018.
     4. "React Design Patterns and Best Practices: Build easy to scale modular applications using the most powerful components and design patterns" авторства Michele Bertoli. – Packt Publishing, 2017.
     5. React: Up & Running: Building Web Applications" авторства Stoyan Stefanov та Габріель Страчан. – O'Reilly Media, 2016














ДОДАТОК А
Здійснення пошуку блюд, які містять потрібні складові
   
 
1 class AppropriateDishesWithIngredientsList(
2 generics.ListCreateAPIView): 
3 """
4 Надання API для відображення страв, що можуть бути приготовані 
5 із вказаних інгредієнтів. 
6 """ 
 
7 serializer_class = serializers.AppropriateDishesSerializer 
 
8 
 
9 def get_queryset(self): 
 
10 """ 
11 Обробка GET-запиту на отримання списку страв. 
12 """ 
13 parameter_key = '0' 
14 query_parameters = self.request.query_params 
15 missed_count_parameter_list = \ 
16 list(query_parameters.getlist(parameter_key)) 
17 missed_count_parameter = \ 
18 int(query_parameters.getlist('1')[0]) \ 
19 
20 parameter_set = \ 
21 set(map(int, list( 
22 query_parameters.getlist(parameter_key)))) 	 
24 return get_dishes_with_ingredients( 
25 parameter_set, missed_count_parameter) 
	26 	 
	27 	 
 
28 def get_dishes_with_ingredients( 
 
29 ingredients: set[int], 
 
30 acceptable_missed_count: int) -> dict[str: list[int]]: 
38 
 
39 dishes = [dish.id for dish in models.Dish.objects.all()] 
 
40 appropriate_dishes = list() 
 
41 almost_appropriate_dishes = list() 
 
42 
 
43 for dish_id in dishes: 
 
44 dish_ingredients = { 
45 item.ingredient_id for item in 
46 models.DishIngredient.objects.filter(dish=dish_id)} 
47 print(dish_ingredients) 
48 not_used_ingredients = \ 
49 dish_ingredients.difference(ingredients) 
50 
51 if not_used_ingredients_count == 0: 
52 appropriate_dishes.append(dish_id) 
53 elif not_used_ingredients_count <= 54 	acceptable_missed_count: 
	55 	almost_appropriate_dishes.append(dish_id) 
	56 	 
 
57 return ( 
 
58 models.Dish.objects.filter( 
59 id__in=appropriate_dishes), 
60 models.Dish.objects.filter( 
61 id__in=almost_appropriate_dishes 

























ДОДАТОК Б
Пошук установ з приготуванням їжі, які мають потрібні нам блюда 


class DishSetCateringEstablishments(
generics.ListAPIView):
serializer_class = \
serializers.CateringEstablishmentSerializer

def get_queryset(self):
query_parameters = self.request.query_params

dish_key = 'dish'
wish_list = set(map(int, list(
query_parameters.getlist(dish_key))))

automated_machines_with_given_dishes = \
models.AutomaticMachineDish.objects.filter(
dish__in=wish_list
)
automated_machines_types_with_given_dishes = \
automated_machines_with_given_dishes. \
values_list('automatic_machine_type')
dishes_cooked_by_machines = \
automated_machines_with_given_dishes.\
values_list('dish')

machine_type_appropriate_dishes = \
get_list_mapped_to_integer(
automated_machines_types_with_given_dishes,
dishes_cooked_by_machines)

catering_establishment_machines = \
get_catering_establishment_machines(
automated_machines_types_with_given_dishes)

catering_establishments_that_cook_given_dishes = \
get_catering_establishments_that_cook_given_dishes(
machine_type_appropriate_dishes,
catering_establishment_machines, wish_list)

searched_catering_establishments = \
models.CateringEstablishment.objects.filter(
id__in=
catering_establishments_that_cook_given_dishes)
searched_catering_establishments = \
choose_catering_establishment_by_location(
query_parameters,
searched_catering_establishments)

return searched_catering_establishmen
ДОДАТОК В
Реалізація передачі замовлення та блюда у розумний пристрій
class Dish {
public:
    Dish(int id = -1, int ingredient_count = -1) 
        : id(id), ingredient_count(ingredient_count) {}

    int get_id() const {
        return id;
    }

    int get_ingredient_count() const {
        return ingredient_count;
    }

    void set_ingredient(int index, Ingredient ingredient) {
        if (index > -1 && index < ingredient_count) {
            ingredients[index] = Ingredient(ingredient.get_id(), ingredient.get_weight_or_volume());
        }
    }

    int get_cook_time_seconds() const {
        int cook_time = 0;
        for (int i = 0; i < ingredient_count; ++i) {
            cook_time += ingredients[i].get_cook_time_seconds();
        }
        return cook_time;
    }

    Ingredient* get_ingredient(int index) const {
        if (index > -1 && index < ingredient_count) {
            return &ingredients[index];
        }
        return nullptr;
    }
private: 
    int id;
    int ingredient_count;
    Ingredient* ingredients;
};

class Order {
public:
    Order(bool user_is_vip = false, int dish_count = 0, Dish* dish = nullptr, 
        int order_id = -1, int shift_count = 0, int index_number = 0)
    : user_is_vip(user_is_vip), order_id(order_id), index_number(index_number),
        shift_count(shift_count), dish(dish), dish_count(dish_count) {}

    bool is_user_vip() const {
        return user_is_vip;
    }
    
    const Dish* get_dish(int index) const {
        return &dish[index];
    }

    int get_order_id() const {
        return order_id;
    }

    int get_shift_count() const {
        return shift_count;
    }

    void increment_shift_count() {
        ++shift_count;
    }

    int get_dish_count() const {
      return dish_count; 
    }

    int get_cook_time_seconds() const {
        int cook_time = 0;
        for (int i = 0; i < dish_count; ++i) {
            cook_time += dish[i].get_cook_time_seconds();
        }
        return cook_time;
    }

    Order* get_next_order() {
        return next_order;
    }

    void set_next_order(Order* new_next_order) {
        next_order = new_next_order;
    }

    Order* get_previous_order() {
        return previous_order;
    }

    void set_previous_order(Order* new_previous_order) {
        previous_order = new_previous_order;
    }

    int get_index_number() const {
        return index_number;
    }

    void set_index_number(int new_number) {
        index_number = new_number;
    }
private:
    bool user_is_vip;
    int dish_count;
    int index_number;
    Dish* dish;
    int order_id;
    int shift_count;
    Order* next_order;
    Order* previous_order;
}; 
ДОДАТОК Ж
Перевірка на плагіат

2



